"""
AI Backend Manager

Manages multiple AI backends with fallback logic.
Tries primary backend first, falls back to secondary if it fails.
"""

import logging
from typing import List, Optional, Dict, Any
from agent_core.ai_backend import AIBackend, AIResponse, WebSearchResult, AIBackendError, create_backend


logger = logging.getLogger(__name__)


class BackendManager:
    """
    Manages multiple AI backends with fallback support
    
    Features:
    - Try backends in priority order
    - Automatic fallback on failure
    - Track backend availability
    - Informative error messages
    """
    
    def __init__(self, backend_configs: List[Dict[str, Any]]):
        """
        Initialize backend manager
        
        Args:
            backend_configs: List of backend configurations, each with:
                - type: Backend type ("openai", "claude", "ollama", "mock")
                - priority: Priority order (lower = higher priority)
                - config: Backend-specific configuration
        """
        self.backends: List[tuple[int, AIBackend]] = []
        self.failed_backends: set = set()
        
        # Initialize backends
        for backend_config in backend_configs:
            try:
                backend_type = backend_config.get('type', 'mock')
                priority = backend_config.get('priority', 999)
                config = backend_config.get('config', {})
                
                backend = create_backend(backend_type, config)
                
                if backend.is_available():
                    self.backends.append((priority, backend))
                    logger.info(f"Initialized backend: {backend.get_name()} (priority {priority})")
                else:
                    logger.warning(f"Backend {backend.get_name()} not available")
                    
            except Exception as e:
                logger.error(f"Failed to initialize backend {backend_config.get('type')}: {e}")
        
        # Sort by priority (lower number = higher priority)
        self.backends.sort(key=lambda x: x[0])
        
        if not self.backends:
            raise AIBackendError("No AI backends available")
        
        logger.info(f"Backend manager initialized with {len(self.backends)} backend(s)")
    
    def generate_response(self, prompt: str, system_prompt: Optional[str] = None,
                         temperature: float = 0.7, max_tokens: int = 1000) -> AIResponse:
        """
        Generate response with fallback
        
        Tries backends in priority order until one succeeds.
        
        Args:
            prompt: User prompt
            system_prompt: Optional system prompt
            temperature: Sampling temperature
            max_tokens: Maximum tokens
            
        Returns:
            AIResponse object
            
        Raises:
            AIBackendError: If all backends fail
        """
        errors = []
        
        for priority, backend in self.backends:
            backend_name = backend.get_name()
            
            # Skip if backend previously failed
            if backend_name in self.failed_backends:
                continue
            
            try:
                logger.info(f"Trying backend: {backend_name}")
                response = backend.generate_response(
                    prompt=prompt,
                    system_prompt=system_prompt,
                    temperature=temperature,
                    max_tokens=max_tokens
                )
                
                if response.success:
                    logger.info(f"✓ Response generated by {backend_name}")
                    response.metadata['backend_used'] = backend_name
                    return response
                else:
                    error_msg = f"{backend_name}: {response.error}"
                    errors.append(error_msg)
                    logger.warning(f"Backend {backend_name} failed: {response.error}")
                    
            except Exception as e:
                error_msg = f"{backend_name}: {str(e)}"
                errors.append(error_msg)
                logger.error(f"Backend {backend_name} error: {e}")
                # Mark backend as failed
                self.failed_backends.add(backend_name)
        
        # All backends failed
        error_summary = "\n".join(f"  - {err}" for err in errors)
        return AIResponse(
            content="",
            success=False,
            error=f"All AI backends failed:\n{error_summary}"
        )
    
    def web_search(self, query: str, num_results: int = 5) -> WebSearchResult:
        """
        Perform web search with fallback
        
        Tries backends that support web search in priority order.
        
        Args:
            query: Search query
            num_results: Number of results
            
        Returns:
            WebSearchResult object
        """
        errors = []
        
        for priority, backend in self.backends:
            backend_name = backend.get_name()
            
            # Skip if backend doesn't support web search
            if not backend.supports_web_search():
                continue
            
            # Skip if backend previously failed
            if backend_name in self.failed_backends:
                continue
            
            try:
                logger.info(f"Trying web search with: {backend_name}")
                result = backend.web_search(query=query, num_results=num_results)
                
                if result.success:
                    logger.info(f"✓ Search completed by {backend_name}")
                    return result
                else:
                    error_msg = f"{backend_name}: {result.error}"
                    errors.append(error_msg)
                    logger.warning(f"Backend {backend_name} search failed: {result.error}")
                    
            except Exception as e:
                error_msg = f"{backend_name}: {str(e)}"
                errors.append(error_msg)
                logger.error(f"Backend {backend_name} search error: {e}")
        
        # No backend supports web search or all failed
        if not errors:
            return WebSearchResult(
                query=query,
                results=[],
                success=False,
                error="No backends support web search"
            )
        
        error_summary = "\n".join(f"  - {err}" for err in errors)
        return WebSearchResult(
            query=query,
            results=[],
            success=False,
            error=f"All web search attempts failed:\n{error_summary}"
        )
    
    def get_available_backends(self) -> List[str]:
        """
        Get list of available backend names
        
        Returns:
            List of backend names
        """
        return [backend.get_name() for _, backend in self.backends 
                if backend.get_name() not in self.failed_backends]
    
    def reset_failed_backends(self):
        """Reset failed backends list (allow retry)"""
        self.failed_backends.clear()
        logger.info("Reset failed backends list")


if __name__ == '__main__':
    # Test backend manager
    import sys
    
    print("Testing Backend Manager...")
    
    # Create manager with mock backend
    configs = [
        {
            "type": "mock",
            "priority": 1,
            "config": {}
        }
    ]
    
    try:
        manager = BackendManager(configs)
        print(f"✓ Manager initialized with backends: {manager.get_available_backends()}")
        
        # Test response generation
        response = manager.generate_response("What is OBD-II?")
        if response.success:
            print(f"✓ Response: {response.content}")
            print(f"✓ Backend used: {response.metadata.get('backend_used')}")
        else:
            print(f"✗ Error: {response.error}")
            sys.exit(1)
        
        # Test web search
        search_result = manager.web_search("Ford Escape diagnostics")
        if search_result.success:
            print(f"✓ Search results: {len(search_result.results)} found")
        else:
            print(f"✗ Search error: {search_result.error}")
        
        print("\nBackend manager tests passed!")
        
    except AIBackendError as e:
        print(f"✗ Manager error: {e}")
        sys.exit(1)
